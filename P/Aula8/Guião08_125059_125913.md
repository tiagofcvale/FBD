# BD: Guião 8


## ​8.1
 
### *a)*

```
CREATE PROCEDURE remover_funcionario 
  @ssn char(9)
AS
BEGIN
  -- Obter o ID do funcionário a ser removido
  DECLARE @v_id char(9);
  SELECT @v_id = Ssn FROM Employee WHERE Ssn = @ssn;
   
  -- Remover entradas na tabela works_on
  DELETE FROM Works_on WHERE Essn = @v_id;
  
  -- Remover dependentes
  DELETE FROM Dependent WHERE Essn = @v_id;
  
  -- Remover funcionário
  DELETE FROM Employee WHERE Ssn = @v_id;

  UPDATE Employee set Super_ssn = NULL where Super_ssn = @ssn;
  
END;

As preocupações adicionais:
- Garantir que tudo é feito numa transação;
- Confirmar que o funcionário existe antes de o apagar;
- Garantir que só os utilizador que têm permissões, é que podem aceder e modificar o Stored Procedure;
- Tratamento de erros.
```

### *b)* 

```
CREATE PROCEDURE Company.getManagerInfo
AS
BEGIN
    -- Obtéém a data atual
    DECLARE @currentDate AS DATE = GETDATE();

    -- Cria uma tabela temporaria para armazenar os dados dos gestores
    CREATE TABLE #ManagerInfo(
        Ssn VARCHAR(10),
        YearsOfService INT
    );

    -- Insere os dados dos gestores na tabela temporaria
    INSERT INTO #ManagerInfo (Ssn, YearsOfService)
    SELECT Mgr_ssn, DATEDIFF(YEAR, Mgr_start_date, @currentDate) AS YearsOfService
    FROM DEPARTMENT WHERE Mgr_ssn IS NOT NULL;

    -- Obtem os dados dos gestores
    SELECT Emp.Fname, Emp.Minit, Emp.Lname, Emp.Ssn, Dep.Mgr_ssn, MI.YearsOfService
    FROM Company.EMPLOYEE EMP
    INNER JOIN Company.DEPARTMENT DEP ON EMP.Ssn = Dep.Mgr_ssn
    INNER JOIN #ManagerInfo MI ON Emp.Ssn = MI.Ssn;

    -- Obtem o SSN e numero de anos do gestor mais antigo
    SELECT TOP 1 Ssn, YearsOfService
    FROM #ManagerInfo
    ORDER BY YearsOfService DESC;

    -- Remove a tabela temporaria
    DROP TABLE #ManagerInfo
end
```

### *c)* 

```
CREATE TRIGGER salary ON Company.DEPARTMENT
AFTER INSERT, UPDATE
AS
BEGIN
    IF EXISTS (
        SELECT Mgr_ssn
        FROM Department
        WHERE Mgr_ssn IN (
            SELECT Mgr_ssn
            FROM inserted
        )
        GROUP BY Mgr_ssn
        HAVING COUNT(*) > 1
    )
    BEGIN
        RAISERROR ('O funcionário já é gestor de outro departamento.', 16, 1);
        ROLLBACK TRANSACTION
        RETURN
    END
END
```

### *d)* 

```
CREATE TRIGGER tr_check_salary ON Company.EMPLOYEE
AFTER INSERT, UPDATE
AS
BEGIN
    -- Verifica se háá funcionarios com salario superior ao gestor do seu departamento
    IF EXISTS (
        SELECT Emp.Ssn
        FROM Company.EMPLOYEE AS Emp
        INNER JOIN Company.DEPARTMENT Dep ON Emp.Dno = Dep.Dnumber
        INNER JOIN Company.EMPLOYEE Manager ON Dep.Mgr_ssn = Manager.Ssn
        WHERE Emp.Ssn IN (
            SELECT Ssn
            FROM inserted
            ) AND Emp.Salary > (Manager.Salary - 1)
    )
    BEGIN
        -- Atualiza o salario dos funcionarios para o salario do gestor com menos 1 unidade
        UPDATE Emp
        SET Emp.Salary = Manager.Salary -1
        FROM Company.EMPLOYEE Emp
        INNER JOIN Company.DEPARTMENT Dep ON Emp.Dno = Dep.Dnumber
        INNER JOIN Company.EMPLOYEE MANAGER ON Dep.Mgr_ssn = MANAGER.Ssn
        WHERE Emp.Ssn IN (
            SELECT Ssn
            FROM inserted
            ) AND Emp.Salary > (Manager.Salary - 1);
    end;
end
```

### *e)* 

```
CREATE FUNCTION emplsprojects
(
    @ssn VARCHAR(9)
)
RETURNS TABLE
AS
RETURN
(
    SELECT p.Pname, p.Plocation
    FROM Company.Project p
    INNER JOIN Company.Works_on w ON p.Pnumber = w.Pno
    INNER JOIN Company.Employee e ON w.Essn = e.Ssn
    WHERE e.Ssn = @ssn
);

GO
SELECT * FROM employeeProjects('183623612');
```

### *f)* 

```
CREATE FUNCTION getEmpsAboveAvgSalary(@Dno INT)

RETURNS TABLE AS
RETURN (
    SELECT Emp.Fname, Emp.Minit, Emp.Lname, Emp.Salary
    FROM Company.EMPLOYEE EMP
    WHERE EMP.Dno = @Dno
    AND Emp.Salary > (
        SELECT AVG(Salary)
        FROM Company.EMPLOYEE
        Where Dno = @Dno
    )
);
```

### *g)* 

```
GO
CREATE FUNCTION company.employeeDeptHighAverage (@Dno INT)
RETURNS @ProjectInfo TABLE
(
    Pname VARCHAR(30),
    Pnumber INT,
    Plocation VARCHAR(20),
    Dnum INT,
    Budget DECIMAL(10,2),
    TotalBudget DECIMAL(10,2)
)
AS
BEGIN
    DECLARE
        @Pname VARCHAR(30),
        @Pnumber INT,
        @Plocation VARCHAR(20),
        @Dnum INT,
        @Budget DECIMAL(10,2),
        @TotalBudget DECIMAL(10,2) = 0,
        @EmployeeSalary DECIMAL(10,2);

    DECLARE project_cursor CURSOR FOR
        SELECT p.Pname, p.Pnumber, p.Plocation, p.Dnum, e.Salary
        FROM Company.Project p
        JOIN Company.Works_on w ON p.Pnumber = w.Pno
        JOIN Company.Employee e ON w.Essn = e.Ssn
        WHERE p.Dnum = @Dno;

    OPEN project_cursor;

    FETCH NEXT FROM project_cursor
        INTO @Pname, @Pnumber, @Plocation, @Dnum, @EmployeeSalary;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        SET @Budget = @EmployeeSalary / 40;
        SET @TotalBudget = @TotalBudget + @Budget;

        INSERT INTO @ProjectInfo (Pname, Pnumber, Plocation, Dnum, Budget, TotalBudget)
        VALUES (@Pname, @Pnumber, @Plocation, @Dnum, @Budget, @TotalBudget);

        FETCH NEXT FROM project_cursor
            INTO @Pname, @Pnumber, @Plocation, @Dnum, @EmployeeSalary;
    END;

    CLOSE project_cursor;
    DEALLOCATE project_cursor;

    RETURN;
END;
GO

SELECT * FROM company.employeeDeptHighAverage(3);
```

### *h)* 

```
-- Trigger After:

CREATE TRIGGER Company.DeleteDepartment On Company.DEPARTMENT
AFTER DELETE
AS
BEGIN
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'dbo' AND TABLE_NAME = 'Department_Deleted')
    BEGIN
        SELECT * INTO Department_Deleted FROM Company.DEPARTMENT WHERE 1 = 0;
    end

    INSERT INTO Department_Deleted
    SELECT* FROM deleted;
end
GO

-- Trigger Instance Of:

CREATE TRIGGER Company.DeleteDepartment ON Company.DEPARTMENT
AFTER DELETE
AS
BEGIN
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'dbo' AND TABLE_NAME = 'Department_Deleted')
    BEGIN
        SELECT * INTO Department_Deleted FROM Company_Department WHERE 1=0;
    end

    INSERT INT Department_Deleted
    SELECT * FROM deleted;

    DELETE FROM Company.Department WHERE Dnumber IN (SELECT Dnumber FROM deleted);
end
```

### *i)* 

```
As Stored Procedures podem devolver zero, um ou vários resultados, permitem parâmetros de entrada e saída, não podem ser usadas em SELECT/WHERE/HAVING, mas podem chamar outras SPs. Suportam exceções e transações.

As Funções (UDFs) devolvem apenas um valor (escalar ou tabela), aceitam só parâmetros de entrada, podem ser usadas em SELECT/WHERE/HAVING, mas não podem chamar SPs. Não suportam exceções nem transações.

```
